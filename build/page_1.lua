-- Code created by Kwik - Copyright: kwiksher.com -- Version: 3.1.6 -- Project: Text_Candy_Help, published on Sat May 03 2014 18:22:01 GMT-0500 local composer = require( "composer" ) local scene = composer.newScene() -- External libraries local TextCandy = require("lib_text_candy") -- Initial settings and checkings local numPages = 1 -- number of pages in the project local sceneGroup = nil -- main group for all page elementslocal _W = display.contentWidth; -- full width of the pagelocal _H = display.contentHeight; -- full height of the page     local curPage = 1 -- number of the current page -- Button names local but_countUPlocal but_applyDeformlocal but_applyAnimlocal but_applyTransilocal but_deleteHeade-- Action names local act_countUp -- Variables names local counterName = "" -- Text Candy Counter Text local headerName = "" -- TextCandy Header Text local countNumber = 0 -- --Counter local countDownName = "" -- Text Candy countDown Text math.randomseed(os.time()) -- All layers on a table local layer = {} -- All audio files on a table local allAudios = {} -- Calculates anchow points local function repositionAnchor( object, newAnchorX, newAnchorY )      local origX = object.x; local origY = object.y      if newAnchorX ~= 0.5 or newAnchorY ~= 0.5 then          local width = object.width; local height = object.height          local xCoord = width * (newAnchorX - .5)           local yCoord = height * (newAnchorY - .5)          object.x = origX + xCoord; object.y = origY + yCoord          object.oriX = object.x; object.oriY = object.y        end end -- Called when the scene's view does not exist:  function scene:create( event )      -- view is not yet visible      local sceneGroup = self.view          -- BEFORE variables     counterName = "" -- Text Candy Counter Text     headerName = "" -- TextCandy Header Text     countNumber = 0 -- --Counter     countDownName = "" -- Text Candy countDown Text     -- Capture and set group position     local function groupPos(obj)        local minX, minY        for i = 1, obj.numChildren do           local currentRecord = obj[ i ]           if i == 1 then              minX = currentRecord.x - currentRecord.contentWidth * 0.5              minY = currentRecord.y - currentRecord.contentHeight * 0.5           end           local mX = currentRecord.x - currentRecord.contentWidth * 0.5           if mX < minX then              minX = mX           end           local mY = currentRecord.y - currentRecord.contentHeight * 0.5           if mY < minY then              minY = mY           end        end        obj.x = minX + obj.contentWidth * 0.5        obj.y = minY + obj.contentHeight * 0.5     end     -- Multilingual items     -- (TOP) External code will render here     -- bg positioning        layer.bg = display.newRect( 512, 384, 1024, 768 )        layer.bg.oriX = layer.bg.x; layer.bg.oriY = layer.bg.y        layer.bg.oriXs = layer.bg.xScale; layer.bg.oriYs = layer.bg.yScale        layer.bg:setFillColor (0.03921568627451, 0.83529411764706, 0.9843137254902)        layer.bg.alpha = 1; layer.bg.oldAlpha = 1        sceneGroup:insert( 1, layer.bg); sceneGroup.bg = layer.bg     -- Header positioning        layer.Header = display.newRect( 496, 66, 502, 60 )        layer.Header.oriX = layer.Header.x; layer.Header.oriY = layer.Header.y        layer.Header.oriXs = layer.Header.xScale; layer.Header.oriYs = layer.Header.yScale        layer.Header:setFillColor (0.96078431372549, 0.0156862745098, 0.12941176470588)        layer.Header.alpha = 1; layer.Header.oldAlpha = 1        sceneGroup:insert( layer.Header); sceneGroup.Header = layer.Header     -- Counter positioning        layer.Counter = display.newRect( 257, 307, 387, 67 )        layer.Counter.oriX = layer.Counter.x; layer.Counter.oriY = layer.Counter.y        layer.Counter.oriXs = layer.Counter.xScale; layer.Counter.oriYs = layer.Counter.yScale        layer.Counter:setFillColor (0.0156862745098, 0.08235294117647, 0.96078431372549)        layer.Counter.alpha = 1; layer.Counter.oldAlpha = 1        sceneGroup:insert( layer.Counter); sceneGroup.Counter = layer.Counter     -- countDown positioning        layer.countDown = display.newRect( 658, 302, 175, 68 )        layer.countDown.oriX = layer.countDown.x; layer.countDown.oriY = layer.countDown.y        layer.countDown.oriXs = layer.countDown.xScale; layer.countDown.oriYs = layer.countDown.yScale        layer.countDown:setFillColor (0.04705882352941, 0.96078431372549, 0.56078431372549)        layer.countDown.alpha = 1; layer.countDown.oldAlpha = 1        sceneGroup:insert( layer.countDown); sceneGroup.countDown = layer.countDown     -- counterButton positioning        layer.counterButton = display.newImageRect( composer.imgDir.. "p1_counterbutton.png", 106, 45 );        layer.counterButton.x = 90; layer.counterButton.y = 544; layer.counterButton.alpha = 1; layer.counterButton.oldAlpha = 1        layer.counterButton.oriX = layer.counterButton.x; layer.counterButton.oriY = layer.counterButton.y        layer.counterButton.oriXs = layer.counterButton.xScale; layer.counterButton.oriYs = layer.counterButton.yScale        layer.counterButton.name = "counterButton"        sceneGroup:insert(layer.counterButton); sceneGroup.counterButton = layer.counterButton     -- Deformations positioning        layer.Deformations = display.newImageRect( composer.imgDir.. "p1_deformations.png", 122, 53 );        layer.Deformations.x = 90; layer.Deformations.y = 609; layer.Deformations.alpha = 1; layer.Deformations.oldAlpha = 1        layer.Deformations.oriX = layer.Deformations.x; layer.Deformations.oriY = layer.Deformations.y        layer.Deformations.oriXs = layer.Deformations.xScale; layer.Deformations.oriYs = layer.Deformations.yScale        layer.Deformations.name = "Deformations"        sceneGroup:insert(layer.Deformations); sceneGroup.Deformations = layer.Deformations     -- animBtn positioning        layer.animBtn = display.newImageRect( composer.imgDir.. "p1_animbtn.png", 114, 53 );        layer.animBtn.x = 91; layer.animBtn.y = 686; layer.animBtn.alpha = 1; layer.animBtn.oldAlpha = 1        layer.animBtn.oriX = layer.animBtn.x; layer.animBtn.oriY = layer.animBtn.y        layer.animBtn.oriXs = layer.animBtn.xScale; layer.animBtn.oriYs = layer.animBtn.yScale        layer.animBtn.name = "animBtn"        sceneGroup:insert(layer.animBtn); sceneGroup.animBtn = layer.animBtn     -- transitionBtn positioning        layer.transitionBtn = display.newImageRect( composer.imgDir.. "p1_transitionbtn.png", 117, 47 );        layer.transitionBtn.x = 246; layer.transitionBtn.y = 547; layer.transitionBtn.alpha = 1; layer.transitionBtn.oldAlpha = 1        layer.transitionBtn.oriX = layer.transitionBtn.x; layer.transitionBtn.oriY = layer.transitionBtn.y        layer.transitionBtn.oriXs = layer.transitionBtn.xScale; layer.transitionBtn.oriYs = layer.transitionBtn.yScale        layer.transitionBtn.name = "transitionBtn"        sceneGroup:insert(layer.transitionBtn); sceneGroup.transitionBtn = layer.transitionBtn     -- deleteBtn positioning        layer.deleteBtn = display.newImageRect( composer.imgDir.. "p1_deletebtn.png", 115, 48 );        layer.deleteBtn.x = 247; layer.deleteBtn.y = 613; layer.deleteBtn.alpha = 1; layer.deleteBtn.oldAlpha = 1        layer.deleteBtn.oriX = layer.deleteBtn.x; layer.deleteBtn.oriY = layer.deleteBtn.y        layer.deleteBtn.oriXs = layer.deleteBtn.xScale; layer.deleteBtn.oriYs = layer.deleteBtn.yScale        layer.deleteBtn.name = "deleteBtn"        sceneGroup:insert(layer.deleteBtn); sceneGroup.deleteBtn = layer.deleteBtn         -- Group(s) creation        -- AFTER variables         -- Hiding elements        layer.countDown.alpha = 0;        layer.Counter.alpha = 0;        layer.Header.alpha = 0;        -- (MIDDLE) External code will render here        -- Text Candy Creation Code-- To be used with "Kwik" Photoshop Plugin  to create CoronaSDK Apps-- Works with CoronaSDK build 2014.2189 or newer and Kwik version 3-- By Hector Sanchez Perez--@Appresario-- April 2014-- **** IMPORTANT***--- Remember to Add the Text Candy Library (lib_text_candy.lua" as external library in Kwik--- and name it "TextCandy". You can buy it from http://x-pressive.com/TextCandy_Corona/---- Also, please add this file (TextCandyHelper.lua) as External Code after the creation of Layers      -------------------------------------------------------------------------------------------------- STEP1.- LOAD CHARACTER SET-- A character set (or bitmap font) is a sprite sheet where all of a font's chars are placed on. -- You can load and use as many different character sets as you like-- My personal preference is to create my own Bitmap Fonts with GlyphDesigner-- Glyph Designer is a comprehensive and easy-to-use tool to create great looking bitmap charsets -- within minutes, including color gradients, highlights, dropshadows, bevels, outlines and more. -- Glyph Designer directly exports into Text Candy format. -- You can get GlyphDesigner from http://71squared.com/en/glyphdesigner---- TextCandy.AddCharsetFromGlyphDesigner("fontName", "dataFile")---- "fontName" can be any name you want, it's the name of the Character set-- "dataFile" is the lua file that Glyph Designer exported, make sure to put this file along-- with its corresponding png image file in the root directory of your project-------------------------------------------------------------------------------------------------TextCandy.AddCharsetFromGlyphDesigner("myFont1", "headerFont")TextCandy.AddCharsetFromGlyphDesigner("myFont2", "counterFont")  --------------------------------------------------------------------------------- --STEP 2.- CREATE TEXT-- Once you loaded one or more fonts, creating text objects is as simple as making a cup of coffee-- You create a handle for each each text you create. ---------------------------------------------------------------------------------headerName = TextCandy.CreateText({        fontName  = "myFont1",        x   = layer.Header.x,        y   = layer.Header.y,        text    = "This is the Header!",        originX   = "CENTER",        originY   = "CENTER",        textFlow  = "CENTER",        wrapWidth = layer.Header.width, --You can set a number or get the width of an object or variable        parentGroup = sceneGroup, -- **Required: Put the name of a display Group or sceneGroup        --charSpacing   = -12,        --lineSpacing = 0,        --showOrigin  = true  }) counterName = TextCandy.CreateText({        fontName  = "myFont2",        x   = layer.Counter.x,        y   = layer.Counter.y,        text    = "Counting down: ",        originX   = "CENTER",        originY   = "CENTER",        textFlow  = "LEFT",        wrapWidth = layer.Counter.width, --You can set a number or get the width of an object or variable        parentGroup = sceneGroup, -- **Required: Put the name of a display Group or sceneGroup                --charSpacing   = -12,        --lineSpacing = 0,        --showOrigin  = true  })   countDownName = TextCandy.CreateText({        fontName  = "myFont2",        x   = layer.countDown.x,        y   = layer.countDown.y,        text    = countNumber, --Text assigned to a variable, so we can udpate the text later on        originX   = "CENTER",        originY   = "CENTER",        textFlow  = "LEFT",        wrapWidth = layer.countDown.width,        parentGroup = sceneGroup, -- **Required: Put the name of a display Group or sceneGroup                --charSpacing   = -12,        --lineSpacing = 0,        --showOrigin  = true  })   ------------------------------------------------------------------------------------- -- AFTER CREATING THE TEXT, YOU CAN DO WITH THEM ANYTHING YOU WANT, LIKE CHANING -- THE CONTENT OF THE TEXT, APPLYING DEFORMATIONS, ANIMATINOS OR TRANSITIONS -- SO CHECK TEXT CANDY WEBSITE AND SAMPLES TO GET IDEAS http://x-pressive.com/TextCandy_Corona/reference.html -- HERE ARE A COUPLE OF EXAMPLES --------------------------------------------------------------------------------------   ------------------------------------ -- SAMPLE1: REPLACE TEXT CONTENT (Text is the name of the text)  ---------------------------------- --Text:setText(countNumber)      ------------------------------------ -- SAMPLE2: APPLY DEFORMATION  (Text is the name of the text) ---------------------------------- --Text:applyDeform(PropertyTable)   ------------------------------------ -- SAMPLE3: APPLY ANIMATION  (Text is the name of the text) ---------------------------------- --Text:applyAnimation( PropertyTable )   ------------------------------------ -- SAMPLE4: APPLY TRANSITION  (Text is the name of the text) ---------------------------------- --Text:applyInOutTransition(PropertyTable)    ------------------------------------ -- SAMPLE5: DELETE TEXT  (Text is the name of the text) ---------------------------------- --Text:delete() --Text = nil          -- Repositions according anchor points end -- ends scene:create-- Called when the scene's view is about to 'will/load' or 'did/appear': function scene:show( event )    local sceneGroup = self.view    if event.phase == "did" then       -- purges previous and next scenes       if nil~= composer.getScene("page_2") then composer.removeScene("page_2", true) end         -- Check for previous bookmarks        if (tonumber(composer.kBookmark) == 1) then           local path = system.pathForFile( "book.txt", system.DocumentsDirectory )           local file = io.open( path, "w+" )           file:write ( curPage.."\n1" )           io.close( file )        end       -- Check for for auto play settings        if (tonumber(composer.kAutoPlay) > 0) then          local function act_autoPlay(event)            if(curPage < numPages) then               if(composer.kBidi == false) then                  composer.gotoScene( "page_"..curPage+1, { effect = "fromRight"} )               else                  composer.gotoScene( "page_"..curPage-1, { effect = "fromLeft"} )               end             end          end          composer.timerStash.timer_AP = timer.performWithDelay( composer.kAutoPlay*1000, act_autoPlay, 1 )        end          -- Actions (functions)        act_countUp = function (event)            countNumber = countNumber + 1       end        --End Actions (functions)        -- Button event listeners        local function oncounterButtonEvent(event)           but_countUP(layer.counterButton)           return true        end        layer.counterButton:addEventListener("tap", oncounterButtonEvent )        local function onDeformationsEvent(event)           but_applyDeform(layer.Deformations)           return true        end        layer.Deformations:addEventListener("tap", onDeformationsEvent )        local function onanimBtnEvent(event)           but_applyAnim(layer.animBtn)           return true        end        layer.animBtn:addEventListener("tap", onanimBtnEvent )        local function ontransitionBtnEvent(event)           but_applyTransi(layer.transitionBtn)           return true        end        layer.transitionBtn:addEventListener("tap", ontransitionBtnEvent )        local function ondeleteBtnEvent(event)           but_deleteHeade(layer.deleteBtn)           return true        end        layer.deleteBtn:addEventListener("tap", ondeleteBtnEvent )        -- Button functions        function but_countUP(self)            act_countUp()            --External code            --Update the Text of countercountDownName:setText(countNumber)        end        function but_applyDeform(self)            --External code            counterName:applyDeform({	type 		= TextCandy.DEFORM_SHAKE,	angleVariation	= 25,	scaleVariation	= 0,	xVariation	= 0,	yVariation	= 10  })        end        function but_applyAnim(self)            --External code            counterName:applyAnimation({	interval		= 1,	startNow		= true,	restartOnChange 	= true,	delay			= 0,	--duration		= 3000,	charWise		= true,	autoRemoveText  	= true,	frequency 		= 250,	startAlpha		= 0.75,	alphaRange		= 0.25,	xScaleRange		= 0.25,	yScaleRange		= 0.25,	rotationRange		= 25,	xRange			= 10,	yRange			= 10  })        end        function but_applyTransi(self)            --External code            counterName:applyInOutTransition({	-- EFFECT SETTINGS	hideCharsBefore = true,	hideCharsAfter  = true,	startNow	= true,	loop		= false,	autoRemoveText  = false,	restartOnChange	= true,	-- IN TRANSITION	inDelay		= 0,	inCharDelay	= 40,	inMode   	= "LEFT_RIGHT",	InSound   	= MySound,	AnimateFrom	= { xScale = 4.0, yScale = 4.0, time = 1000 },	-- OUT TRANSITION	outDelay	= 3000,	outCharDelay	= 40,	outMode   	= "RIGHT_LEFT",	OutSound   	= MySound,	AnimateTo	= { xScale = 4.0, yScale = 4.0, time = 1000 }  })        end        function but_deleteHeade(self)            --External code             headerName:delete() headerName = nil        end        -- swipe this page with spacer of 120 in normal direction        composer.Gesture.activate( layer.bg, {swipeLength=120} )        composer.pageSwap = function (event )          local options           if event.phase == "ended" and event.direction ~= nil then              local wPage = curPage              if event.direction == "left" and composer.kBidi == false then                 wPage = curPage + 1                 if wPage > numPages then wPage = curPage end                 options = { effect = "fromRight"}             elseif event.direction == "left" and composer.kBidi == true then                 wPage = curPage - 1                 if wPage < 1 then wPage = 1 end                 options = { effect = "fromLeft"}             elseif event.direction == "right" and composer.kBidi == true then                 wPage = curPage + 1                 if wPage > numPages then wPage = curPage end                 options = { effect = "fromRight"}             elseif event.direction == "right" and composer.kBidi == false then                 wPage = curPage - 1                 if wPage < 1 then wPage = 1 end                 options = { effect = "fromLeft"}             end              if tonumber(wPage) ~= tonumber(curPage) then                composer.gotoScene("page_"..wPage, options)             end          end         end        layer.bg:addEventListener( composer.Gesture.SWIPE_EVENT, composer.pageSwap )        composer.test = composer.pageSwap        -- (BOTTOM) External code will render here    end --ends phase did end -- ends scene:showfunction scene:hide( event )    -- all disposal happens here    if event.phase == "will" then           layer.bg:removeEventListener( composer.Gesture.SWIPE_EVENT, composer.pageSwap );            --composer.Gesture.deactivate(layer.bg)           composer.cancelAllTimers();    elseif event.phase == "did" then           composer.test = nil    end end  function scene:destroy( event )    -- Remove all unecessary composer items    --composer.pageSwap = nil end scene:addEventListener( "create", scene ) scene:addEventListener( "show", scene ) scene:addEventListener( "hide", scene ) scene:addEventListener( "destroy", scene ) return scene 